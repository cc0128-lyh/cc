<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebAR Cyber-Particles: åˆæ™¨</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', sans-serif; }
        canvas { display: block; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00FFFF; font-size: 20px; text-align: center; pointer-events: none;
            text-shadow: 0 0 15px #00FFFF; z-index: 10; letter-spacing: 2px;
        }
        #ui-layer {
            position: absolute; bottom: 30px; left: 30px; 
            color: rgba(255,255,255,0.7); pointer-events: none; 
            font-size: 12px; line-height: 1.8;
            text-shadow: 0 0 2px black;
            border-left: 2px solid #00FFFF;
            padding-left: 15px;
        }
        .highlight { color: #00FFFF; font-weight: bold; }
        .red-text { color: #FF2255; font-weight: bold; }
        .input_video { display: none; }
    </style>
</head>
<body>

    <div id="loading">SYSTEM INITIALIZING...<br><span style="font-size:12px; opacity:0.7;">ACCESSING NEURAL LINK</span></div>
    
    <div id="ui-layer">
        <div>ğŸ– <span class="highlight">çƒä½“ (Sphere)</span></div>
        <div>âœŒï¸ <span class="highlight">æ–‡å­— (Text: æ¬£é›¨)</span></div>
        <div>ğŸ¤˜ <span class="highlight">åŒèºæ—‹ (DNA)</span> - <span style="font-size:10px">NEW!</span></div>
        <div>â˜ï¸ <span class="highlight">æ˜Ÿç¯ (Star)</span></div>
        <div>ğŸ‘ <span class="red-text">çˆ±å¿ƒ (Heart)</span></div>
        <div>ğŸ‘Œ <span class="highlight">é»‘æ´å¼•åŠ› (Gravity)</span> - <span style="font-size:10px">HOLD IT!</span></div>
    </div>
    
    <video class="input_video"></video>

    <script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>

    <script>
        // --- æ ¸å¿ƒé…ç½® ---
        const CONFIG = {
            count: 18000,          // ç²’å­æ•°é‡å¢åŠ åˆ° 1.8w
            colorCyan: 0x00FFFF,   // èµ›åšé’
            colorRed: 0xFF0044,    // éœ“è™¹çº¢
            colorWhite: 0xFFFFFF,  // é«˜äº®ç™½
            cameraZ: 450,
            stiffness: 0.04,       // å¼¹æ€§ (å›å¼¹åŠ›åº¦)
            damping: 0.93,         // é˜»å°¼ (é¡ºæ»‘åº¦)
            explosionForce: 20.0,  // çˆ†å‘åŠ›
            noiseAmp: 3.0,         // å™ªæ³¢æŒ¯å¹… (å‘¼å¸æ„Ÿå¼ºåº¦)
            gravityForce: 15.0     // é»‘æ´å¸åŠ›
        };

        // å…¨å±€çŠ¶æ€
        let scene, camera, renderer, particles, geometry;
        let positions, targets, velocities, colors, originalColors;
        let time = 0;
        
        let currentShape = 'scatter';
        let targetColorVec = new THREE.Color(CONFIG.colorCyan);
        let currentColorVec = new THREE.Color(CONFIG.colorCyan);
        
        // äº¤äº’çŠ¶æ€
        let handState = {
            detected: false,
            position: new THREE.Vector3(),
            velocity: new THREE.Vector3(),
            prevPos: new THREE.Vector3(),
            scale: 1.0,
            targetScale: 1.0,
            isPinching: false // é»‘æ´æ¨¡å¼
        };

        // å½¢çŠ¶ç¼“å­˜
        const shapesCache = {};

        // --- 1. çº¹ç†ç”Ÿæˆ (è®©ç²’å­å¸¦å…‰æ™•) ---
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // --- 2. åˆå§‹åŒ– ---
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.0012); // é»‘è‰²è¿·é›¾

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.z = CONFIG.cameraZ;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶åƒç´ æ¯”ä»¥ä¼˜åŒ–æ€§èƒ½
            document.body.appendChild(renderer.domElement);

            initParticles();
            initShapes();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        }

        function initParticles() {
            geometry = new THREE.BufferGeometry();
            positions = new Float32Array(CONFIG.count * 3);
            targets = new Float32Array(CONFIG.count * 3);
            velocities = new Float32Array(CONFIG.count * 3);
            colors = new Float32Array(CONFIG.count * 3);
            originalColors = new Float32Array(CONFIG.count * 3); // å­˜å‚¨å½“å‰çš„åŸºç¡€é¢œè‰²ï¼ˆä¸å«é«˜äº®ï¼‰

            const baseColor = new THREE.Color(CONFIG.colorCyan);

            for (let i = 0; i < CONFIG.count; i++) {
                // åˆå§‹æ•£å¼€
                positions[i*3] = (Math.random()-0.5) * 1500;
                positions[i*3+1] = (Math.random()-0.5) * 1000;
                positions[i*3+2] = (Math.random()-0.5) * 1000;
                
                // ç›®æ ‡å½’é›¶
                targets[i*3] = 0; targets[i*3+1] = 0; targets[i*3+2] = 0;

                colors[i*3] = baseColor.r;
                colors[i*3+1] = baseColor.g;
                colors[i*3+2] = baseColor.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 3.5,
                map: createGlowTexture(), // ä½¿ç”¨å…‰æ™•çº¹ç†
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.9
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- 3. å½¢çŠ¶å·¥å‚ ---
        const Shapes = {
            scatter: () => {
                const arr = new Float32Array(CONFIG.count * 3);
                for (let i = 0; i < CONFIG.count; i++) {
                    arr[i*3] = (Math.random()-0.5) * 1200;
                    arr[i*3+1] = (Math.random()-0.5) * 1200;
                    arr[i*3+2] = (Math.random()-0.5) * 1200;
                }
                return arr;
            },
            sphere: () => {
                const arr = new Float32Array(CONFIG.count * 3);
                for (let i = 0; i < CONFIG.count; i++) {
                    const phi = Math.acos(-1 + (2 * i) / CONFIG.count);
                    const theta = Math.sqrt(CONFIG.count * Math.PI) * phi;
                    const r = 140;
                    arr[i*3] = r * Math.cos(theta) * Math.sin(phi);
                    arr[i*3+1] = r * Math.sin(theta) * Math.sin(phi);
                    arr[i*3+2] = r * Math.cos(phi);
                }
                return arr;
            },
            dna: () => { // NEW: åŒèºæ—‹ DNA
                const arr = new Float32Array(CONFIG.count * 3);
                for (let i = 0; i < CONFIG.count; i++) {
                    // ä¸¤æ¡é“¾
                    const strand = i % 2 === 0 ? 1 : -1;
                    const t = (i / CONFIG.count) * Math.PI * 12; // åœˆæ•°
                    const r = 60;
                    const h = 350; // é«˜åº¦
                    
                    // èºæ—‹åæ ‡
                    let x = Math.cos(t) * r * strand;
                    let z = Math.sin(t) * r * strand;
                    let y = (i / CONFIG.count - 0.5) * h;

                    // åŠ ä¸€ç‚¹éšæœºæ‚ç‚¹ä½œä¸ºåŸºå› é”®
                    if (Math.random() > 0.8) {
                        x *= Math.random();
                        z *= Math.random();
                    }

                    arr[i*3] = x;
                    arr[i*3+1] = y;
                    arr[i*3+2] = z;
                }
                return arr;
            },
            star: () => {
                const arr = new Float32Array(CONFIG.count * 3);
                for(let i=0; i<CONFIG.count; i++) {
                    const angle = (Math.floor(Math.random() * 5) * 72 * Math.PI / 180) - Math.PI/2;
                    const dist = Math.random() * 160;
                    // å¢åŠ Zè½´åšåº¦ï¼Œæ›´æœ‰ä½“ç§¯æ„Ÿ
                    const spreadZ = (Math.random() - 0.5) * 60 * (1 - dist/160); 
                    arr[i*3] = Math.cos(angle) * dist + (Math.random()-0.5)*10;
                    arr[i*3+1] = Math.sin(angle) * dist + (Math.random()-0.5)*10;
                    arr[i*3+2] = spreadZ;
                }
                return arr;
            },
            heart: () => {
                const arr = new Float32Array(CONFIG.count * 3);
                for (let i = 0; i < CONFIG.count; i++) {
                    let t = Math.random() * Math.PI * 2;
                    // æ”¹è¿›çš„å¿ƒå½¢å¡«å……ç®—æ³•
                    let r = Math.pow(Math.random(), 0.3) * 10; 
                    let x = 16 * Math.pow(Math.sin(t), 3);
                    let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    arr[i*3] = x * r;
                    arr[i*3+1] = y * r + 20;
                    arr[i*3+2] = (Math.random() - 0.5) * r * 4; // æ ¹æ®åŠå¾„åŠ åšåº¦
                }
                return arr;
            },
            text: () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 400; canvas.height = 200;
                ctx.fillStyle = '#000'; ctx.fillRect(0, 0, 400, 200);
                ctx.fillStyle = '#FFF'; 
                ctx.font = '900 100px "Impact", sans-serif'; // æ›´ç²—çš„å­—ä½“
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('æ¬£é›¨', 200, 100);
                
                const data = ctx.getImageData(0,0,400,200).data;
                const pixels = [];
                for(let y=0; y<200; y+=2) {
                    for(let x=0; x<400; x+=2) {
                        if(data[(y*400+x)*4] > 128) {
                            pixels.push({x: (x-200)*2.2, y: -(y-100)*2.2});
                        }
                    }
                }
                
                const arr = new Float32Array(CONFIG.count * 3);
                for(let i=0; i<CONFIG.count; i++) {
                    const p = pixels[i % pixels.length];
                    arr[i*3] = p.x + (Math.random()-0.5)*4;
                    arr[i*3+1] = p.y + (Math.random()-0.5)*4;
                    arr[i*3+2] = (Math.random()-0.5)*30;
                }
                return arr;
            }
        };

        function initShapes() {
            for (const key in Shapes) shapesCache[key] = Shapes[key]();
            setShape('scatter', CONFIG.colorCyan, false);
            // åˆå§‹ç›´æ¥å¯¹é½
            for(let i=0; i<CONFIG.count*3; i++) positions[i] = targets[i];
        }

        function setShape(name, colorHex, explode = true) {
            if (currentShape === name && !handState.isPinching) {
                // å¦‚æœä»…ä»…æ˜¯é¢œè‰²å˜äº†
                targetColorVec.setHex(colorHex);
                return;
            }
            
            currentShape = name;
            targetColorVec.setHex(colorHex);

            const tArr = shapesCache[name];
            for(let i=0; i<CONFIG.count*3; i++) targets[i] = tArr[i];

            if (explode) {
                for(let i=0; i<CONFIG.count; i++) {
                    const idx = i*3;
                    const amp = CONFIG.explosionForce;
                    velocities[idx] += (Math.random()-0.5) * amp;
                    velocities[idx+1] += (Math.random()-0.5) * amp;
                    velocities[idx+2] += (Math.random()-0.5) * amp;
                }
            }
        }

        // --- 4. ç‰©ç†å¼•æ“ (The Magic) ---
        function updatePhysics() {
            time += 0.01;
            
            // é¢œè‰²å¹³æ»‘
            currentColorVec.lerp(targetColorVec, 0.05);
            
            // æ‰‹éƒ¨çŠ¶æ€è®¡ç®—
            let stormForce = 0;
            if (handState.detected) {
                const speed = handState.velocity.length();
                if (speed > 8) stormForce = speed * 4.0;
                
                // ç¼©æ”¾å¹³æ»‘
                handState.scale += (handState.targetScale - handState.scale) * 0.1;
            } else {
                handState.scale += (1.0 - handState.scale) * 0.1;
                handState.velocity.set(0,0,0);
            }
            
            particles.scale.setScalar(handState.scale);
            
            // DNA ç‰¹æ•ˆï¼šå¦‚æœå½“å‰æ˜¯ DNAï¼Œè®©æ•´ä½“æ—‹è½¬
            if (currentShape === 'dna') {
                particles.rotation.y += 0.01;
                particles.rotation.z = Math.sin(time * 0.5) * 0.1; // å¾®å¾®å€¾æ–œ
            } else {
                // å…¶ä»–å½¢çŠ¶ç¼“æ…¢å¤ä½æ—‹è½¬
                particles.rotation.y *= 0.95;
                particles.rotation.z *= 0.95;
            }

            const positionsArr = geometry.attributes.position.array;
            const colorsArr = geometry.attributes.color.array;

            // é¢„è®¡ç®—é»‘æ´ä¸­å¿ƒ (å°†æ‰‹éƒ¨åæ ‡è½¬ä¸º World Space è¿‘ä¼¼å€¼)
            // å‡è®¾æ‰‹åœ¨ z=0 å¹³é¢
            const handX = handState.position.x;
            const handY = handState.position.y;
            const handZ = 0;

            for (let i = 0; i < CONFIG.count; i++) {
                const idx = i * 3;
                
                let px = positionsArr[idx];
                let py = positionsArr[idx+1];
                let pz = positionsArr[idx+2];
                
                let vx = velocities[idx];
                let vy = velocities[idx+1];
                let vz = velocities[idx+2];
                
                let tx = targets[idx];
                let ty = targets[idx+1];
                let tz = targets[idx+2];

                // --- A. åŸºç¡€å¼¹ç°§åŠ› ---
                let ax = (tx - px) * CONFIG.stiffness;
                let ay = (ty - py) * CONFIG.stiffness;
                let az = (tz - pz) * CONFIG.stiffness;

                // --- B. é‡å­å™ªæ³¢ (Living Field) ---
                // è®©ç²’å­æ°¸è¿œåœ¨åŠ¨ï¼Œæ¨¡æ‹Ÿé‡å­æ¶¨è½
                const noiseF = CONFIG.noiseAmp;
                ax += Math.sin(time * 2.0 + py * 0.01) * 0.02 * noiseF;
                ay += Math.cos(time * 1.5 + px * 0.01) * 0.02 * noiseF;
                az += Math.sin(time * 1.8 + pz * 0.01) * 0.02 * noiseF;

                // --- C. äº¤äº’åŠ›åœº ---
                if (handState.detected) {
                    const dx = px - handX;
                    const dy = py - handY;
                    const dz = pz - handZ;
                    const distSq = dx*dx + dy*dy + dz*dz;
                    const dist = Math.sqrt(distSq) + 0.1;

                    // 1. é»‘æ´å¼•åŠ› (Pinch)
                    if (handState.isPinching) {
                        // å¼ºåŠ›å¸å…¥
                        if (distSq < 250000) { // 500èŒƒå›´
                            const gForce = CONFIG.gravityForce / (dist * 0.1); 
                            ax -= (dx / dist) * gForce;
                            ay -= (dy / dist) * gForce;
                            az -= (dz / dist) * gForce;
                        }
                    } 
                    // 2. æŒ¥æ‰‹é£æš´ (Wind)
                    else if (stormForce > 10 && distSq < 40000) {
                        const wForce = stormForce / dist;
                        ax += (dx / dist) * wForce;
                        ay += (dy / dist) * wForce;
                        az += (dz / dist) * wForce;
                    }
                }

                // æ›´æ–°ç‰©ç†
                vx += ax; vy += ay; vz += az;
                vx *= CONFIG.damping; vy *= CONFIG.damping; vz *= CONFIG.damping;
                
                px += vx; py += vy; pz += vz;

                positionsArr[idx] = px;
                positionsArr[idx+1] = py;
                positionsArr[idx+2] = pz;
                
                velocities[idx] = vx;
                velocities[idx+1] = vy;
                velocities[idx+2] = vz;

                // --- D. è§†è§‰ç‰¹æ•ˆï¼šé€Ÿåº¦é«˜äº® (Velocity Glow) ---
                // è®¡ç®—å½“å‰é€Ÿåº¦çš„æ ‡é‡
                const speed = Math.sqrt(vx*vx + vy*vy + vz*vz);
                
                // åŸºç¡€é¢œè‰²æ’å€¼
                let r = currentColorVec.r;
                let g = currentColorVec.g;
                let b = currentColorVec.b;

                // å¦‚æœé€Ÿåº¦å¿«ï¼Œå åŠ ç™½è‰²
                if (speed > 2.0) {
                    const glowFactor = Math.min((speed - 2.0) * 0.15, 1.0);
                    r = r * (1 - glowFactor) + glowFactor; // æ··å…¥ç™½è‰² (1.0, 1.0, 1.0)
                    g = g * (1 - glowFactor) + glowFactor;
                    b = b * (1 - glowFactor) + glowFactor;
                }

                colorsArr[idx] = r;
                colorsArr[idx+1] = g;
                colorsArr[idx+2] = b;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
        }

        // --- 5. MediaPipe å¤„ç† ---
        const videoEl = document.querySelector('.input_video');
        
        function onResults(results) {
            document.getElementById('loading').style.display = 'none';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handState.detected = true;
                const lm = results.multiHandLandmarks[0];
                
                // åæ ‡æ˜ å°„
                const x = (0.5 - lm[9].x) * window.innerWidth * 1.0;
                const y = (0.5 - lm[9].y) * window.innerHeight * 1.0;
                const currentPos = new THREE.Vector3(x, y, 0);
                
                // è®¡ç®—æ‰‹é€Ÿ
                handState.velocity.subVectors(currentPos, handState.prevPos);
                handState.prevPos.copy(currentPos);
                handState.position.lerp(currentPos, 0.4); // å¹³æ»‘ä½ç½®

                // è®¡ç®—æ‰‹æŒå¤§å° (ç¼©æ”¾)
                let minX=1, maxX=0, minY=1, maxY=0;
                lm.forEach(p => {
                    if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x;
                    if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y;
                });
                const area = (maxX-minX)*(maxY-minY);
                handState.targetScale = 0.5 + area * 4.0;

                // æ‰‹åŠ¿è¯†åˆ«
                analyzeGesture(lm);
            } else {
                handState.detected = false;
            }
        }

        function analyzeGesture(lm) {
            const isUp = (tip, pip) => {
                // ç®€å•å‘é‡åˆ¤æ–­ï¼Œæ›´ç¨³å¥
                return lm[tip].y < lm[pip].y; // å±å¹•åæ ‡ y å‘ä¸‹
            };
            const dist = (i, j) => Math.hypot(lm[i].x-lm[j].x, lm[i].y-lm[j].y);

            const thumbUp = isUp(4, 3); // æ‹‡æŒ‡æ¯”è¾ƒç‰¹æ®Šçš„å…³èŠ‚
            const indexUp = isUp(8, 6);
            const middleUp = isUp(12, 10);
            const ringUp = isUp(16, 14);
            const pinkyUp = isUp(20, 18);

            // é»‘æ´åˆ¤å®šï¼šé£ŸæŒ‡å°–ä¸æ‹‡æŒ‡å°–æåˆ (Pinch)
            const pinchDist = dist(4, 8);
            if (pinchDist < 0.05) {
                handState.isPinching = true;
                setShape(currentShape, CONFIG.colorWhite, false); // æä½æ—¶ç¨å¾®å˜ç™½
                return; // æåˆæ—¶é˜»æ–­å…¶ä»–æ‰‹åŠ¿
            } else {
                handState.isPinching = false;
            }

            let shape = currentShape;
            let color = CONFIG.colorCyan;

            // é€»è¾‘æ ‘
            const fingers = [thumbUp, indexUp, middleUp, ringUp, pinkyUp];
            const upCount = fingers.filter(Boolean).length;

            if (upCount === 5) {
                shape = 'sphere'; // å¼ æ‰‹
            } else if (indexUp && middleUp && !ringUp && !pinkyUp) {
                shape = 'text'; // å‰ªåˆ€æ‰‹
            } else if (indexUp && !middleUp && !ringUp && !pinkyUp) {
                shape = 'star'; // é£ŸæŒ‡
            } else if (indexUp && !middleUp && !ringUp && pinkyUp) {
                shape = 'dna'; // ğŸ¤˜ Rock/Spider-Man -> DNA
            } else if (thumbUp && !indexUp) {
                shape = 'heart'; color = CONFIG.colorRed; // ç«–å¤§æ‹‡æŒ‡
            } else if (upCount === 0) {
                shape = 'scatter'; // æ¡æ‹³ -> æ•£å¼€/åœ†ç¯ (è¿™é‡Œæ”¹ä¸ºæ•£å¼€æ›´æœ‰å†²å‡»åŠ›)
            }

            setShape(shape, color);
        }

        // --- å¯åŠ¨é€»è¾‘ ---
        const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.6 });
        hands.onResults(onResults);

        const cam = new Camera(videoEl, {
            onFrame: async () => await hands.send({image: videoEl}),
            width: 640, height: 480
        });
        cam.start();

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>